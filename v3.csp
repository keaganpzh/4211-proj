//Messages through the Acceptor channels are of format: proposer id(1 or 2), n, proposed value(-1 if none, 10/20 if there is a value)
channel A1 2;
channel A2 2;
channel A3 2;

//Messages through the Proposer channels are of format: n (-1 to denote NACK), m (last accepted promise, -1 to denote none), val (last accepted value). proposers dont need to know which acceptor this response came from.
channel P1Ack 3;
channel P2Ack 3;

// values that the proposers want to propose
#define P1Val 10;
#define P2Val 20;

//Proposer 1 counter variables
var P1_numPromises = 0;
var P1_max_m = -1;
var P1_max_val = -1;

var A1_max_n = -1; //last promise
var A1_last_m = -1; //last accepted
var A1_last_val =-1;


var A2_max_n = -1; //last promise
var A2_last_m = -1; //last accepted
var A2_last_val =-1;

var A3_max_n = -1; //last promise
var A3_last_m = -1; //last accepted
var A3_last_val =-1;
#define goal A1_last_val == A2_last_val || A1_last_val == A3_last_val || A2_last_val == A3_last_val;

Proposer1(n) = A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> 
  test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}}-> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
  if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> Proposer1(n+3)} 
  else {
  		findmax {
  			var counter = 0;
  			var array_m = [m1, m2, m3];
  			var array_val = [v1, v2, v3];
  			while (counter < 3) {
  				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
  				counter = counter + 1;
  			}} -> if (P1_max_m > -1) {
  				//something was accepted - propagate the acccepted value
    			A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Proposer1(n+3)
  			} else {
  				A1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Proposer1(n+3)
  			}
  		};
  
Acceptor1(last_n, last_m, last_val) = A1?prop.n.val -> if (val == -1 ) {Acceptor1PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor1PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}
														  } else {
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)}
														  };
														  		

Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}
												   } else {
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor1(n, n, val)} else {P2Ack!n.n.val -> Acceptor1(n, n, val)}
												   };
														

//// Acceptor Process
//Acceptor(id) = 
//    prepare?n -> Acceptor(id);
//
//// System Composition
//PaxosSystem = 
//    Proposer(1)