//Messages through the Acceptor channels are of format: proposer id(1 or 2), n, proposed value(-1 if none, 10/20 if there is a value)
channel A1 2;
channel A2 2;
channel A3 2;

//Messages through the Proposer channels are of format: n (-1 to denote NACK), m (last accepted promise, -1 to denote none), val (last accepted value). proposers dont need to know which acceptor this response came from.
channel P1Ack 3;
channel P2Ack 3;
var P1Nack = 0;
var P2Nack = 0;

// Learner channels
channel L1 3;
channel L2 3;

// values that the proposers want to propose
#define P1Val 10;
#define P2Val 20;

//Proposer 1 counter variables
var P1_numPromises = 0;
var P1_max_m = -1;
var P1_max_val = -1;

//Proposer 2 counter variables
var P2_numPromises = 0;
var P2_max_m = -1;
var P2_max_val = -1;

var A1_last_n = -1; //last promise
var A1_last_m = -1; //last accepted
var A1_last_val =-1;

var A2_last_n = -1; //last promise
var A2_last_m = -1; //last accepted
var A2_last_val =-1;

var A3_last_n = -1; //last promise
var A3_last_m = -1; //last accepted
var A3_last_val =-1;

// Learner variables
var L1_val = -1;
var L2_val = -1;

//The consensus case, where at least 2 of the 3 acceptors must agree on the same value. The value cannot be -1 since that is the flag to denote the absence of a value.
#define consensus (A1_last_val == A2_last_val && A1_last_val != -1) || (A1_last_val == A3_last_val && A1_last_val != -1) || (A2_last_val == A3_last_val && A2_last_val != -1);

//BASIC PAXOS IN ERROR FREE SCENARIO

//For the basic scenario, there is one proposer who tries to propose a value to 3 acceptors. Eventually, we just have to check if the consensus is reached where at least 2 of the 3 acceptors share a common value.
//The proposer and 3 acceptors are running in an interleaving pattern.
//The proposer can choose to either send a PREPARE or a ACCEPT request, in the event that the proposer has received a majority promise.
//The acceptor must decide if the request it receives is a PREPARE or ACCEPT request, and then send either a NACK(in the event the promise is smaller than its previous promsie), or a PROMISE.

//First proposer
Proposer1(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
	if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> Proposer1(n+2)} // Did not receive majority promise, retry
	else {
	    // Respond to majority promise
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
				counter = counter + 1;
			}} -> if (P1_max_m > -1) {
				// Something was accepted, send ACCEPT with the accepted value
				A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop
			} else {
		        // Nothing accepted yet, send ACCEPT with our value
				A1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop
			}
	};
  
// Second Proposer
Proposer2(n) = 
	A1!2.n.-1 -> A2!2.n.-1 -> A3!2.n.-1 -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 ->  P2Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} -> test3{if(n3==n) {P2_numPromises = P2_numPromises + 1;}} ->
	if (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> Proposer2(n+2)} // Did not receive majority promise, retry 
	else {
	    // Respond to majority PROMISE/ACCEPTED
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}
				counter = counter + 1;
			}} -> if (P2_max_m > -1) {
				//something was accepted, send ACCEPT with the accepted value
				A1!2.n.P2_max_val -> A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
			} else {
			    // Nothing accepted yet, send ACCEPT with our value
				A1!2.n.P2Val -> A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
			}
	};


Acceptor1(last_n, last_m, last_val) = updateAllVars{A1_last_n = last_n; A1_last_m = last_m; A1_last_val = last_val;} -> A1?prop.n.val 
//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.
	-> if (val == -1 ) {Acceptor1PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor1PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor1(last_n, last_m, last_val)}
														  } else {
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)}
														  };
														  		

Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}
												   } else {
												   		L1!P1_max_val -> L2!P1_max_val ->
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor1(n, n, val)} else {P2Ack!n.n.val -> Acceptor1(n, n, val)}
												   };
														

Acceptor2(last_n, last_m, last_val) = updateAllVars{A2_last_n = last_n; A2_last_m = last_m; A2_last_val = last_val;} -> A2?prop.n.val 
//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.
	-> if (val == -1 ) {Acceptor2PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor2AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor2PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor2(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor2(last_n, last_m, last_val)}
														  } else {
														        L1!P1_max_val -> L2!P1_max_val ->
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor2(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor2(n, last_m, last_val)}
														  };
														  		

Acceptor2AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)}
												   } else {
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor2(n, n, val)} else {P2Ack!n.n.val -> Acceptor2(n, n, val)}
												   };

Acceptor3(last_n, last_m, last_val) = updateAllVars{A3_last_n = last_n; A3_last_m = last_m; A3_last_val = last_val;} -> A3?prop.n.val 
//The acceptor needs to decide if the request it is hearing is a PREPARE or a ACCEPT request.
	-> if (val == -1 ) {Acceptor3PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor3AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor3PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> nack{P1Nack = last_n} -> Acceptor3(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> nack{P2Nack = last_n} -> Acceptor3(last_n, last_m, last_val)}
														  } else {
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor3(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor3(n, last_m, last_val)}
														  };
														  		

Acceptor3AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)}
												   } else {
												   		L1!P1_max_val -> L2!P1_max_val ->
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor3(n, n, val)} else {P2Ack!n.n.val -> Acceptor3(n, n, val)}
												   };
												   
Learner1() = L1?val -> update_val{L1_val = val} -> Learner1();	

Learner2()= L2?val -> update_val{L2_val = val} -> Learner2();											   


System() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();

#assert System() deadlockfree;


// Basic Paxos, error-free scenario
#assert System() |= <> consensus; // expect VALID


/////////////////////////////////////////////////
////////////ERROR SCENARIOS/////////////////////
////////////////////////////////////////////////



//SCENARIO 1: BASIC PAXOS WITH ACCEPTOR FAILURE
//one of the acceptor will fail, so there will only be 2 acceptors. Consensus should still be reached with the new quorum size of 2.


// 1. Acceptor Failure
FailedAcceptor(last_n, last_m, last_val) = A3?prop.n.val -> if (n == 1) { P1Ack!-1.-1.-1 -> Skip } else { P2Ack!-1.-1.-1 -> Skip }; // Simulate a failed acceptor
System_AcceptorFailure() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| FailedAcceptor(-1, -1, -1);
#assert System_AcceptorFailure() |= <> consensus; // expect VALID



//SCENARIO 2: BASIC PAXOS WITH REDUNDANT LEARNER FAILURE
//One of the learners will fail, which should not prevent the the acceptors from achieving consensus.

// 2. Redundant Learner Failure
FailedLearner() = Stop; // simulate a failed learner
System_RedundantLearnerFailure() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| FailedLearner();
#assert System_RedundantLearnerFailure() |= <> consensus; // expect VALID



//SCENARIO 3: BASIC PAXOS WHEN A PROPOSER FAILS
//One of the proposers will fail during the middle of an ACCEPT message, so only one acceptor receives the accept request. A new leader is elected(proposer 2) which will then propose a new value, and consensus is reached.
// 3. Proposer Failure
// 3. Proposer Failure
FailedProposer(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
	if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> FailedProposer(n+2)} // Did not receive majority promise, retry
	else {
	    // Respond to majority promise
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
				counter = counter + 1;
			}} -> if (P1_max_m > -1) {
				// Fail in the middle of sending ACCEPT, initiate new leader
				A1!1.n.P1_max_val -> Proposer2(2)
			} else {
		        // Fail in the middle of sending ACCEPT, initiate new leader
				A1!1.n.P1Val -> Proposer2(2)
			}
	};
	
System_ProposerFailure() = FailedProposer(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
// We want the consensus to be the failed proposer's value that is accepted by all
#define proposerFailure_consensus (A1_last_val == A2_last_val && A1_last_val == P1Val) || (A1_last_val == A3_last_val && A1_last_val == P1Val) || (A2_last_val == A3_last_val && A2_last_val == P1Val);
#assert System_ProposerFailure |= <> proposerFailure_consensus; // expect VALID



////SCENARIO 4: BASIC PAXOS WHEN MULTIPLE PROPOSERS CONFLICT
// In this scenario, 2 proposers will repeatedly send PREPARE with higher promises, which causes the other proposer's next request to be ignored. In this scenrio, consensus MAY NOT BE REACHED
// 4. Conflicting Proposers
ConflictingProposer1Part1(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> ConflictingProposer1Part2(2) ||| ConflictingProposer2(2); // Dies after receiving promise, then spawns leader new proposer and revives
	
ConflictingProposer1Part2(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> sync -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
	if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> ConflictingProposer1Part2(n+2)} // Did not receive majority promise, retry
	else {
	    // Respond to majority promise
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
				counter = counter + 1;
			}
		} -> // simulate a failure here
			if (P1_max_m > -1) {
				// Something was accepted, send ACCEPT with the accepted value
				A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop
			} else {
		        // Nothing accepted yet, send ACCEPT with our value
				A1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop
			}
	};
	
ConflictingProposer2(n) = 
	A1!2.n.-1 -> A2!2.n.-1 -> A3!2.n.-1 -> sync -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 ->  P2Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} -> test3{if(n3==n) {P2_numPromises = P2_numPromises + 1;}} ->
	if (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> ConflictingProposer2(n+2)} // Did not receive majority promise, retry 
	else {
	    // Respond to majority PROMISE/ACCEPTED
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}
				counter = counter + 1;
			}
		} -> if (P2_max_m > -1) {
				//something was accepted, send ACCEPT with the accepted value
				A1!2.n.P2_max_val -> A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
			} else {
			    // Nothing accepted yet, send ACCEPT with our value
				A1!2.n.P2Val -> A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
			}
	};
	
System_ConflictingProposers() = ConflictingProposer1Part1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
#define nack_level_4 (P1Nack >= 2 || P2Nack >= 2);
#assert System_ConflictingProposers() |= <> consensus; // expect NOT VALID
#assert System_ConflictingProposers() reaches nack_level_4;



////SCENARIO 5: BASIC PAXOS WITH ACCEPTOR ACCEPTING 2 DIFFERENT VALUES
// One propose only sends ACCEPT to one of the acceptors. The other proposer sends ACCEPT to the other 2 acceptors, achieveing consensus. 
// 5. Acceptor Accepting Two Different Values
// 5. Acceptor Accepting Two Different Values
SemiFailedProposer1(n) = 
  A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
  test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
  if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> SemiFailedProposer1(n+2)} // Did not receive majority promise, retry
  else {
      // Respond to majority promise
      // Find the latest accepted value, if any
    findmax {
      var counter = 0;
      var array_m = [m1, m2, m3];
      var array_val = [v1, v2, v3];
      while (counter < 2) {
        if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
        counter = counter + 1;
      }} -> if (P1_max_m > -1) {
        // Fail in the middle of sending ACCEPT, initiate new leader
        A1!1.n.P1_max_val -> SemiFailedProposer2(2)
      } else {
            // Fail in the middle of sending ACCEPT, initiate new leader
        A1!1.n.P1Val -> SemiFailedProposer2(2)
      }
  };
  
SemiFailedProposer2(n) = 
  A2!2.n.-1 -> A3!2.n.-1 -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 -> // Send PREPARE, receive PROMISE
  test1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} ->
  if (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> SemiFailedProposer2(n+2)} // Did not receive majority promise, retry 
  else {
      // Respond to majority PROMISE/ACCEPTED
      // Find the latest accepted value, if any
    findmax {
      var counter = 0;
      var array_m = [m1, m2];
      var array_val = [v1, v2];
      while (counter < 2) {
        if (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}
        counter = counter + 1;
      }} -> if (P2_max_m > -1) {
        //something was accepted, send ACCEPT with the accepted value
        A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
      } else {
          // Nothing accepted yet, send ACCEPT with our value
        A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
      }
  };

System_AcceptorTwoValues() = SemiFailedProposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
// We want the consensus to have the value of the surviving proposer that proposes its value after the first proposer fails.
#define acceptorTwoValues_consensus (A1_last_val == A2_last_val && A1_last_val == P2Val) || (A1_last_val == A3_last_val && A1_last_val == P2Val) || (A2_last_val == A3_last_val && A2_last_val == P2Val);
#assert System_AcceptorTwoValues() |= <> acceptorTwoValues_consensus;


// SCENARIO 6: BASIC PAXOS WITH INSUFFICIENT MULTI-IDENTIFIER MAJORITY
// Proposer 1 achieves acceptance of a value, before failing. Proposer 2 achives the acceptance of a second value, before failing. Proposer 3 finds one acceptor that has previously accepted V1, and therefore has to propose V1.
// Proposer 3 manages to get 2 acceptors to accept this value before failing. However, the acceptors that accepted this value did not accept V1 with the same identifier. 
// Finally, proposer 4 parepares the quorum that has not seen the highest identifier. The consensus is reached.
// 6. Insufficient multi-identifier majority



//SCENARIO 7: BASIC PAXOS WHERE NEW PROPOSERS CANNOT CHANGE AN EXISTING CONSENSUS
// A new proposer when entering is unable to prepare a majority that does not include at least one acceptor which has previously accepted a value. It is therefore forced to propose the same value.
// Consensus shoudl be reached.
// 7. New Proposers Unable to Change Existing Consensus
NewProposer1(n) = 
  A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
  test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
  if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> NewProposer1(n+2)} // Did not receive majority promise, retry
  else {
      // Respond to majority promise
      // Find the latest accepted value, if any
    findmax {
      var counter = 0;
      var array_m = [m1, m2, m3];
      var array_val = [v1, v2, v3];
      while (counter < 3) {
        if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
        counter = counter + 1;
      }} -> if (P1_max_m > -1) {
        // Fail after sending ACCEPT to two Acceptors, initiate new leader
        A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> Proposer2(2)
      } else {
            // Fail after sending ACCEPT to two Acceptors, initiate new leader
        A1!1.n.P1Val -> A2!1.n.P1Val -> Proposer2(2)
      }
  };

System_NewProposersCannotChangeConsensus() = NewProposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
// We want the consensus to have the value of the surviving proposer that proposes its value after the first proposer fails.
#define newProposersCannotChangeConsensus_consensus (A1_last_val == A2_last_val && A1_last_val == P1Val) || (A1_last_val == A3_last_val && A1_last_val == P1Val) || (A2_last_val == A3_last_val && A2_last_val == P1Val);
#assert System_NewProposersCannotChangeConsensus() |= <> newProposersCannotChangeConsensus_consensus;