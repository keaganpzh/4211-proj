//Messages through the Acceptor channels are of format: proposer id(1 or 2), n, proposed value(-1 if none, 10/20 if there is a value)
channel A1 2;
channel A2 2;
channel A3 2;

//Messages through the Proposer channels are of format: n (-1 to denote NACK), m (last accepted promise, -1 to denote none), val (last accepted value). proposers dont need to know which acceptor this response came from.
channel P1Ack 3;
channel P2Ack 3;

// Learner channels
channel L1 1;
channel L2 1;

// values that the proposers want to propose
#define P1Val 10;
#define P2Val 20;

//Proposer 1 counter variables
var P1_numPromises = 0;
var P1_max_m = -1;
var P1_max_val = -1;

//Proposer 2 counter variables
var P2_numPromises = 0;
var P2_max_m = -1;
var P2_max_val = -1;

var A1_last_n = -1; //last promise
var A1_last_m = -1; //last accepted
var A1_last_val =-1;

var A2_last_n = -1; //last promise
var A2_last_m = -1; //last accepted
var A2_last_val =-1;

var A3_last_n = -1; //last promise
var A3_last_m = -1; //last accepted
var A3_last_val =-1;

// Learner variables
var L1_val = -1;
var L2_val = -1;

#define consensus (A1_last_val == A2_last_val && A1_last_val != -1) || (A1_last_val == A3_last_val && A1_last_val != -1) || (A2_last_val == A3_last_val && A2_last_val != -1);

Proposer1(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
	if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> Proposer1(n+2)} // Did not receive majority promise, retry
	else {
	    // Respond to majority promise
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
				counter = counter + 1;
			}} -> if (P1_max_m > -1) {
				// Something was accepted, send ACCEPT with the accepted value
				A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> L1!P1_max_val -> L2!P1_max_val -> Stop
			} else {
		        // Nothing accepted yet, send ACCEPT with our value
				A1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop
			}
	};
  
Proposer2(n) = 
	A1!2.n.-1 -> A2!2.n.-1 -> A3!2.n.-1 -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 ->  P2Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} -> test3{if(n3==n) {P2_numPromises = P2_numPromises + 1;}} ->
	if (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> Proposer2(n+2)} // Did not receive majority promise, retry 
	else {
	    // Respond to majority PROMISE/ACCEPTED
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}
				counter = counter + 1;
			}} -> if (P2_max_m > -1) {
				//something was accepted, send ACCEPT with the accepted value
				A1!2.n.P2_max_val -> A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> L1!P2_max_val -> L2!P2_max_val -> Stop
			} else {
			    // Nothing accepted yet, send ACCEPT with our value
				A1!2.n.P2Val -> A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
			}
	};


Acceptor1(last_n, last_m, last_val) = updateAllVars{A1_last_n = last_n; A1_last_m = last_m; A1_last_val = last_val;} -> A1?prop.n.val 
	-> if (val == -1 ) {Acceptor1PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor1PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}
														  } else {
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor1(n, last_m, last_val)}
														  };
														  		

Acceptor1AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor1(last_n, last_m, last_val)}
												   } else {
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor1(n, n, val)} else {P2Ack!n.n.val -> Acceptor1(n, n, val)}
												   };
														

Acceptor2(last_n, last_m, last_val) = updateAllVars{A2_last_n = last_n; A2_last_m = last_m; A2_last_val = last_val;} -> A2?prop.n.val 
	-> if (val == -1 ) {Acceptor2PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor2AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor2PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)}
														  } else {
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor2(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor2(n, last_m, last_val)}
														  };
														  		

Acceptor2AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor2(last_n, last_m, last_val)}
												   } else {
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor2(n, n, val)} else {P2Ack!n.n.val -> Acceptor2(n, n, val)}
												   };

Acceptor3(last_n, last_m, last_val) = updateAllVars{A3_last_n = last_n; A3_last_m = last_m; A3_last_val = last_val;} -> A3?prop.n.val 
	-> if (val == -1 ) {Acceptor3PromisePath(n, prop, last_n, last_m, last_val)} else {Acceptor3AcceptPath(n, prop, val, last_n, last_m, last_val)};

Acceptor3PromisePath(n, prop, last_n, last_m, last_val) = if (n < last_n) {
																//NACK
																if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)}
														  } else {
														  		if (prop == 1) {P1Ack!n.last_m.last_val -> Acceptor3(n, last_m, last_val)} else {P2Ack!n.last_m.last_val -> Acceptor3(n, last_m, last_val)}
														  };
														  		

Acceptor3AcceptPath(n, prop, val, last_n, last_m, last_val) = if (n < last_n) {
												    	if (prop == 1) {P1Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)} else {P2Ack!-1.-1.-1 -> Acceptor3(last_n, last_m, last_val)}
												   } else {
												   		if (prop == 1) {P1Ack!n.n.val -> Acceptor3(n, n, val)} else {P2Ack!n.n.val -> Acceptor3(n, n, val)}
												   };
												   
Learner1() = L1?val -> update_val{L1_val = val} -> Stop;	

Learner2()= L2?val -> update_val{L2_val = val} -> Stop;											   


System() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();

#assert System() deadlockfree;


// Basic Paxos, error-free scenario
#assert System() |= <> consensus; // expect VALID


// 1. Acceptor Failure
FailedAcceptor(last_n, last_m, last_val) = A3?prop.n.val -> if (n == 1) { P1Ack!-1.-1.-1 -> Skip } else { P2Ack!-1.-1.-1 -> Skip }; // Simulate a failed acceptor
System_AcceptorFailure() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| FailedAcceptor(-1, -1, -1);
#assert System_AcceptorFailure() |= <> consensus; // expect VALID


// 2. Redundant Learner Failure
FailedLearner() = Stop; // simulate a failed learner
System_RedundantLearnerFailure() = Proposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| FailedLearner();
#assert System_RedundantLearnerFailure() |= <> consensus; // expect VALID


// 3. Proposer Failure
FailedProposer(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
	if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> FailedProposer(n+2)} // Did not receive majority promise, retry
	else {
	    // Respond to majority promise
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
				counter = counter + 1;
			}} -> if (P1_max_m > -1) {
				// Fail in the middle of sending ACCEPT, initiate new leader
				A1!1.n.P1_max_val -> Proposer2(2)
			} else {
		        // Fail in the middle of sending ACCEPT, initiate new leader
				A1!1.n.P1Val -> Proposer2(2)
			}
	};
	
System_ProposerFailure() = FailedProposer(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
// We want the consensus to be the failed proposer's value that is accepted by all
#define proposerFailure_consensus (A1_last_val == A2_last_val && A1_last_val == P1Val) || (A1_last_val == A3_last_val && A1_last_val == P1Val) || (A2_last_val == A3_last_val && A2_last_val == P1Val);
#assert System_ProposerFailure |= <> proposerFailure_consensus; // expect VALID


// 4. Conflicting Proposers
var P1Nack = 0;
var P2Nack = 0;

ConflictingProposer1Part1(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> (ConflictingProposer2(2) ||| ConflictingProposer1Part2(2)); // Dies after receiving promise, then spawns leader new proposer and revives
	
ConflictingProposer1Part2(n) = 
	A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
	updateNack{if (n1 == -1 || n2 == -1 || n3 == -1) {P1Nack = n;}}  -> 
	if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> ConflictingProposer1Part2(n+2)} // Did not receive majority promise, retry
	else {
	    // Respond to majority promise
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
				counter = counter + 1;
			}
		} -> // simulate a failure here
			if (P1_max_m > -1) {
				// Something was accepted, send ACCEPT with the accepted value
				A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> A3!1.n.P1_max_val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> L1!P1_max_val -> L2!P1_max_val -> Stop
			} else {
		        // Nothing accepted yet, send ACCEPT with our value
				A1!1.n.P1Val -> A2!1.n.P1Val -> A3!1.n.P1Val -> reset_P1_fields{P1_numPromises = 0; P1_max_m = -1; P1_max_val = -1;} -> Stop
			}
	};
	
ConflictingProposer2(n) = 
	A1!2.n.-1 -> A2!2.n.-1 -> A3!2.n.-1 -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 ->  P2Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
	test1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} -> test3{if(n3==n) {P2_numPromises = P2_numPromises + 1;}} ->
	updateNack{if (n1 == -1 || n2 == -1 || n3 == -1) {P2Nack = n;}}  -> 
	if (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> ConflictingProposer2(n+2)} // Did not receive majority promise, retry 
	else {
	    // Respond to majority PROMISE/ACCEPTED
	    // Find the latest accepted value, if any
		findmax {
			var counter = 0;
			var array_m = [m1, m2, m3];
			var array_val = [v1, v2, v3];
			while (counter < 3) {
				if (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}
				counter = counter + 1;
			}
		} -> if (P2_max_m > -1) {
				//something was accepted, send ACCEPT with the accepted value
				A1!2.n.P2_max_val -> A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> L1!P2_max_val -> L2!P2_max_val -> Stop
			} else {
			    // Nothing accepted yet, send ACCEPT with our value
				A1!2.n.P2Val -> A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
			}
	};
	
System_ConflictingProposers() = ConflictingProposer1Part2(1) ||| ConflictingProposer2(2) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
#define nack_level_4 (P1Nack >= 4 || P2Nack >= 4);
#assert System_ConflictingProposers() |= <> consensus; // expect NOT VALID
#assert System_ConflictingProposers() reaches nack_level_4; 


// 5. Acceptor Accepting Two Different Values
SemiFailedProposer1(n) = 
  A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
  test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
  if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> SemiFailedProposer1(n+2)} // Did not receive majority promise, retry
  else {
      // Respond to majority promise
      // Find the latest accepted value, if any
    findmax {
      var counter = 0;
      var array_m = [m1, m2, m3];
      var array_val = [v1, v2, v3];
      while (counter < 2) {
        if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
        counter = counter + 1;
      }} -> if (P1_max_m > -1) {
        // Fail in the middle of sending ACCEPT, initiate new leader
        A1!1.n.P1_max_val -> SemiFailedProposer2(2)
      } else {
            // Fail in the middle of sending ACCEPT, initiate new leader
        A1!1.n.P1Val -> SemiFailedProposer2(2)
      }
  };
  
SemiFailedProposer2(n) = 
  A2!2.n.-1 -> A3!2.n.-1 -> P2Ack?n1.m1.v1 -> P2Ack?n2.m2.v2 -> // Send PREPARE, receive PROMISE
  test1{if(n1 == n) {P2_numPromises = P2_numPromises + 1;}} -> test2{if(n2==n) {P2_numPromises = P2_numPromises + 1;}} ->
  if (P2_numPromises < 2) {reset_promises{P2_numPromises = 0;} -> SemiFailedProposer2(n+2)} // Did not receive majority promise, retry 
  else {
      // Respond to majority PROMISE/ACCEPTED
      // Find the latest accepted value, if any
    findmax {
      var counter = 0;
      var array_m = [m1, m2];
      var array_val = [v1, v2];
      while (counter < 2) {
        if (P2_max_m < array_m[counter]) {P2_max_m = array_m[counter]; P2_max_val = array_val[counter];}
        counter = counter + 1;
      }} -> if (P2_max_m > -1) {
        //something was accepted, send ACCEPT with the accepted value
        A2!2.n.P2_max_val -> A3!2.n.P2_max_val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> L1!P2_max_val -> L2!P2_max_val -> Stop
      } else {
          // Nothing accepted yet, send ACCEPT with our value
        A2!2.n.P2Val -> A3!2.n.P2Val -> reset_P2_fields{P2_numPromises = 0; P2_max_m = -1; P2_max_val = -1;} -> Stop
      }
  };

System_AcceptorTwoValues() = SemiFailedProposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
// We want the consensus to have the value of the surviving proposer that proposes its value after the first proposer fails.
#define acceptorTwoValues_consensus (A1_last_val == A2_last_val && A1_last_val == P2Val)  (A1_last_val == A3_last_val && A1_last_val == P2Val)  (A2_last_val == A3_last_val && A2_last_val == P2Val);
#assert System_AcceptorTwoValues() |= <> acceptorTwoValues_consensus;


// 6. Insufficient Multi-Identifier Majority
// TODO


// 7. New Proposers Unable to Change Existing Consensus
NewProposer1(n) = 
  A1!1.n.-1 -> A2!1.n.-1 -> A3!1.n.-1 -> P1Ack?n1.m1.v1 -> P1Ack?n2.m2.v2 ->  P1Ack?n3.m3.v3 -> // Send PREPARE, receive PROMISE
  test1{if(n1 == n) {P1_numPromises = P1_numPromises + 1;}} -> test2{if(n2==n) {P1_numPromises = P1_numPromises + 1;}} -> test3{if(n3==n) {P1_numPromises = P1_numPromises + 1;}} ->
  if (P1_numPromises < 2) {reset_promises{P1_numPromises = 0;} -> NewProposer1(n+2)} // Did not receive majority promise, retry
  else {
      // Respond to majority promise
      // Find the latest accepted value, if any
    findmax {
      var counter = 0;
      var array_m = [m1, m2, m3];
      var array_val = [v1, v2, v3];
      while (counter < 3) {
        if (P1_max_m < array_m[counter]) {P1_max_m = array_m[counter]; P1_max_val = array_val[counter];}
        counter = counter + 1;
      }} -> if (P1_max_m > -1) {
        // Fail after sending ACCEPT to two Acceptors, initiate new leader
        A1!1.n.P1_max_val -> A2!1.n.P1_max_val -> Proposer2(2)
      } else {
            // Fail after sending ACCEPT to two Acceptors, initiate new leader
        A1!1.n.P1Val -> A2!1.n.P1Val -> Proposer2(2)
      }
  };

System_NewProposersCannotChangeConsensus() = NewProposer1(1) ||| Acceptor1(-1, -1, -1) ||| Acceptor2(-1, -1, -1) ||| Acceptor3(-1, -1, -1) ||| Learner1() ||| Learner2();
// We want the consensus to have the value of the surviving proposer that proposes its value after the first proposer fails.
#define newProposersCannotChangeConsensus_consensus (A1_last_val == A2_last_val && A1_last_val == P1Val)  (A1_last_val == A3_last_val && A1_last_val == P1Val)  (A2_last_val == A3_last_val && A2_last_val == P1Val);
#assert System_NewProposersCannotChangeConsensus() |= <> newProposersCannotChangeConsensus_consensus;